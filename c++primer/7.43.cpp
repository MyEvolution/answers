#include<iostream>
class NoDefault
{
	

	public:
			int m;
			int i;
		//NoDefault()=default;
	NoDefault(int a):m(a){
	}
};
NoDefault n(0); 
class C
{
	public:
	NoDefault a{0};//隐式转换 
	int i; 
	//发现这里除了直接初始化以外都能进行
	//如发生了隐式转换后的列表初始化，拷贝初始化，
	//有可能是因为这只是一条声明 除了直接初始化和构造 
	//其他的都是在构造时执行（我的理解） 
	//即使是内置类型也是如此 
	//而直接初始化将初始化进行在构造前  这是不被允许的 
	//C()=default;
	C(){
		
	}
};
/*当c是合成的默认构造函数时   编译可以通过 
但是无法创建一个对象 
因为 无法为C合成默认构造函数
(默认构造函数是编译器合成的  在没有用到之前不会合成？)
a执行默认初始化  所以调用默认构造 但是没有 所以无法合成C的默认构造

当c定义默认构造函数(未使用列表初始值)时 无法通过编译
因为未使用列表初始值时  对象a会先被初始化再被赋值
a被初始化执行默认初始化需要用到默认构造  因为没有 所以它没有初始值
使用列表初始值时直接进行初始化 
可执行（除了初始化）语句是否只能出现在函数中 
*/
int main()
{
	C A;
	std::cout<<int(5.5)+5<<std::endl;//显式转换的另一种写法 
	std::cout<<A.a.m<<std::endl;
}
