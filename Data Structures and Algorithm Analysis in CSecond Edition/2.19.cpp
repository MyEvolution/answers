#include<stdio.h>
int mainp(int *num,int n)
{
	 int m;
	 int i,j=0;
	 int b[100];
	 int p=0;
	if(n<=2)
	return num[0];  
	for(i=0;i+1<n;i+=2)
	  if(num[i]==num[i+1])
	   b[j++]=num[i];
	 if((n&1)&&(j%2)==0)
	  b[j++]=num[n-1]; 
	 m=mainp(b,j);
	for(i=0;i<n;i++)
	  if(num[i]==m)
	     p++;
	     if(p>n/2)
          return m;
  else  
       return EOF;
}
main()
{
	int a[100];
	int n;
	int i;
	scanf("%d",&n);
	for(i=0;i<n;i++)
	scanf("%d",&a[i]);
	printf(mainp(a,n)==EOF?"no major element!\n":"%d\n",mainp(a,n));
 } 
 /*
 寻找主要元素
 元素个数大于N/2的元素被称为主要元素
 观察一段数
 4 4 5 5 6 5 5 5 
 以上数字5为主要元素
 以两个为一组  有重复则提出来
 因为如果N为偶数，且有b为主要元素
 那么一定可以找出至少一个候选元为b 
 将找到的候选元在放到数组B里   重复上述操作
 直到候选元个数小于等于2
 如上次  4 5 5 B数组内 
 这时候就牵扯到另一个问题 
 4 5 提不候选元 5 单独又无法提出
 所以当N为奇数时又如何提取？
 比如上个例子
 以及这个例子
 2 5 4 5 3 5 5
 5是主要元素  
 也就说明可能出现在最后
 所以先忽略最后一个元素
 如果没有候选元 再把最后一个放入候选元
 但是同时又有一个问题
 比如 4 4 5 5 4 
 候选元选出来为4 5
 因为要递归 
 所以只能返回一个值
 递归返回指针十分复杂
 那么又该返回谁呢？
 如果把4也拉入 就不会有这种问题了 
 所以我们假象  当B的个数是偶数的时候再把最后一个 加进去
 这样就很轻松的找出唯一的候选元了
 现在证明为什么后一个是偶数的时候加上最后一个是可行的 
 如果偶数中可以选出下一个候选元 ，也就是超过一半 那增加最后一个并不影响这个候选元的被选出
 如上个 4 5 4，可以选出真正的候选元了
 4 
 如果4 4 5 5 3
 4 5 3
 3 
 这样没有真正的主要元素 所以谁做候选元就无所谓了 
 所以奇数最后剩下的一定是一个
 而偶数可能最后剩下两个
 如果两个一样 那么选谁都一样
 如果两个不一样，那么将没有主要元素
 同样无所谓
 2 4 4 4 5 5 
  综上 这是一个神奇的算法4 4 4 4 4 4 
  时间复杂度 
  T(N)=N/2+T(N/2);
  T1==1;
  T2==1;
  T3=1+1=2
  T4=2+1=3
  T8=4+3=7
  T16=8+7=15
  Tn=n-1
  也就是O(N) 
 */ 
  
